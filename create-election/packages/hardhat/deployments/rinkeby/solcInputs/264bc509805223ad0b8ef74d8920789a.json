{
  "language": "Solidity",
  "sources": {
    "contracts/YourContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\n\n/** \n * @title PTBallot\n * @dev Implements publically viewable party designation and time limitation to the standard delegate voting contract\n */\n\ncontract PTBallot {\n   \n    struct Voter {\n        uint weight; // weight is accumulated by delegation\n        bool voted;  // if true, that person already voted\n        address delegate; // person delegated to\n        uint vote;   // index of the voted candidate\n    }\n\n    struct Candidate {\n        // If you can limit the length to a certain number of bytes, \n        // always use one of bytes1 to bytes32 because they are much cheaper\n        bytes32 name;   // short name (up to 32 bytes)\n        bytes32 party; // party name (up to 32 bytes)\n        uint voteCount; // number of accumulated votes\n    }\n\n    address public chairperson;\n\n    uint public expirationDate;\n\n    mapping(address => Voter) private voters;\n\n    Candidate[] public candidates;\n\n    /** \n     * @dev Create a new ballot to choose one of 'candidateNames'.\n     * @dev Limits amountOfDays to uint8 (0-255) to limit the max ballot timelength.\n     * @param candidateNames names of candidates\n     * @param candidateParties names of parties\n     * @param amountOfDays number of days ballot is open\n    \n     */\n    constructor(bytes32[] memory candidateNames, bytes32[] memory candidateParties, address chairAddress, uint8 amountOfDays) {\n        require(candidateNames.length == candidateParties.length);\n        require(amountOfDays != 0);\n        chairperson = chairAddress;\n        voters[chairperson].weight = 1;\n\n        expirationDate = block.timestamp + (amountOfDays * 1 days);\n\n        for (uint i = 0; i < candidateNames.length; i++) {\n            // 'Candidate({...})' creates a temporary\n            // Candidate object and 'candidates.push(...)'\n            // appends it to the end of 'candidates'.\n            candidates.push(Candidate({\n                name: candidateNames[i],\n                party: candidateParties[i],\n                voteCount: 0\n            }));\n        }\n    }\n\n\n    //@dev: modifier to restrict voting functions unless the ballot is within the expirationDate;\n    modifier isNotExpired() \n    {\n        require(block.timestamp < expirationDate);\n            _;\n    }\n        \n    \n    /** \n     * @dev Give 'voter' the right to vote on this ballot. May only be called by 'chairperson'.\n     * @param voter address of voter\n     */\n    function giveRightToVote(address voter) public isNotExpired {\n        require(\n            msg.sender == chairperson,\n            \"Only chairperson can give right to vote.\"\n        );\n        require(\n            !voters[voter].voted,\n            \"The voter already voted.\"\n        );\n        require(voters[voter].weight == 0);\n        voters[voter].weight = 1;\n    }\n\n    /**\n     * @dev Delegate your vote to the voter 'to'.\n     * @param to address to which vote is delegated\n     */\n    function delegate(address to) public isNotExpired {\n        Voter storage sender = voters[msg.sender];\n        require(!sender.voted, \"You already voted.\");\n        require(to != msg.sender, \"Self-delegation is disallowed.\");\n\n        while (voters[to].delegate != address(0)) {\n            to = voters[to].delegate;\n\n            // We found a loop in the delegation, not allowed.\n            require(to != msg.sender, \"Found loop in delegation.\");\n        }\n        sender.voted = true;\n        sender.delegate = to;\n        Voter storage delegate_ = voters[to];\n        if (delegate_.voted) {\n            // If the delegate already voted,\n            // directly add to the number of votes\n            candidates[delegate_.vote].voteCount += sender.weight;\n        } else {\n            // If the delegate did not vote yet,\n            // add to her weight.\n            delegate_.weight += sender.weight;\n        }\n    }\n\n    /**\n     * @dev Give your vote (including votes delegated to you) to candidate 'candidates[candidate].name'.\n     * @param candidate index of candidate in the candidates array\n     */\n    function vote(uint candidate) public isNotExpired {\n        Voter storage sender = voters[msg.sender];\n        require(sender.weight != 0, \"Has no right to vote\");\n        require(!sender.voted, \"Already voted.\");\n        sender.voted = true;\n        sender.vote = candidate;\n\n        // If 'candidate' is out of the range of the array,\n        // this will throw automatically and revert all\n        // changes.\n        candidates[candidate].voteCount += sender.weight;\n    }\n\n    /** \n     * @dev Computes the winning candidate taking all previous votes into account.\n     * @return winningCandidate_ index of winning candidate in the candidates array\n     */\n    function winningCandidate() public view\n            returns (uint winningCandidate_)\n    {\n        uint winningVoteCount = 0;\n        for (uint p = 0; p < candidates.length; p++) {\n            if (candidates[p].voteCount > winningVoteCount) {\n                winningVoteCount = candidates[p].voteCount;\n                winningCandidate_ = p;\n            }\n        }\n    }\n\n    /** \n     * @dev Calls winningCandidate() function to get the index of the winner contained in the candidates array and then\n     * @return winnerName_ the name of the winner\n     * @return winnerParty_ the party of the winner\n     */\n    function winnerDetails() public view\n            returns (bytes32 winnerName_, bytes32 winnerParty_)\n    {\n        winnerName_ = candidates[winningCandidate()].name;\n        winnerParty_ = candidates[winningCandidate()].party;\n    }\n    \n\n    /** \n     * @dev Gets the time left for a ballot by subtracting the expiration date from the current date.\n     * @return endDate_ the time left, in days, before the ballot expires\n\n     */\n     function ballotEndDate() public view\n            returns (uint endDate_)\n    {\n        endDate_ = expirationDate - block.timestamp;\n    }\n}\n/** \n * @title YourContract\n   @notice You can use this control contract to create and view Ballots using the PTBallot contract\n //@dev Functions are designed to limit gas cost and deploy a Ballot with maximum visibility and minimal issue\n */\n \ncontract YourContract {\n    PTBallot public newBallot;\n    address[] public deployedBallots;\n    mapping(uint256 => address) public idToBallot;\n    uint256 public ballotId;\n\n        /**\n     * @notice This function starts an election by deploying a new PTBallot contract\n     * @dev each parameter goes into the constructor of the PTBallot contract to deploy\n     * @param candidateNames names of candidates\n     * @param candidateParties names of parties\n     * @param myAddress address set as the owner of the ballot\n     * @param amountOfDays number of days ballot is open (limited from 0-255)\n     */\n    function startElec (bytes32[] memory candidateNames, bytes32[] memory candidateParties, address myAddress, uint8 amountOfDays) public returns(uint256)  {\n            newBallot = new PTBallot (candidateNames, candidateParties, myAddress, amountOfDays);\n            deployedBallots.push(address(newBallot));\n            ballotId += 1;\n            idToBallot[ballotId] = address(newBallot);\n            return ballotId;\n        }\n \n//@dev function to get all of the Ballots that have been deployed.\n//@return deployedBallots list of all contract addresses of deployed Ballots\n    function getsDeployedBallots() public view returns( address[] memory)\n    {return deployedBallots;}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}